// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlcgen

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const assignRole = `-- name: AssignRole :exec
INSERT INTO authority.account_roles (account_id, role_id)
SELECT $1, r.id FROM authority.roles r WHERE r.name = $2
ON CONFLICT DO NOTHING
`

type AssignRoleParams struct {
	AccountID uuid.UUID `json:"account_id"`
	Name      string    `json:"name"`
}

func (q *Queries) AssignRole(ctx context.Context, arg AssignRoleParams) error {
	_, err := q.db.ExecContext(ctx, assignRole, arg.AccountID, arg.Name)
	return err
}

const deleteIdentity = `-- name: DeleteIdentity :exec
DELETE FROM authority.account_identities WHERE account_id = $1 AND provider = $2
`

type DeleteIdentityParams struct {
	AccountID uuid.UUID `json:"account_id"`
	Provider  string    `json:"provider"`
}

func (q *Queries) DeleteIdentity(ctx context.Context, arg DeleteIdentityParams) error {
	_, err := q.db.ExecContext(ctx, deleteIdentity, arg.AccountID, arg.Provider)
	return err
}

const findAccountByProvider = `-- name: FindAccountByProvider :one
SELECT a.id, a.email, a.email_verified, a.display_name, a.photo_url, a.is_active, a.last_login_at
FROM authority.accounts a
JOIN authority.account_identities i ON i.account_id = a.id
WHERE i.provider = $1 AND i.provider_uid = $2 AND a.deleted_at IS NULL
`

type FindAccountByProviderParams struct {
	Provider    string         `json:"provider"`
	ProviderUid sql.NullString `json:"provider_uid"`
}

type FindAccountByProviderRow struct {
	ID            uuid.UUID      `json:"id"`
	Email         string         `json:"email"`
	EmailVerified sql.NullBool   `json:"email_verified"`
	DisplayName   sql.NullString `json:"display_name"`
	PhotoUrl      sql.NullString `json:"photo_url"`
	IsActive      sql.NullBool   `json:"is_active"`
	LastLoginAt   sql.NullTime   `json:"last_login_at"`
}

func (q *Queries) FindAccountByProvider(ctx context.Context, arg FindAccountByProviderParams) (FindAccountByProviderRow, error) {
	row := q.db.QueryRowContext(ctx, findAccountByProvider, arg.Provider, arg.ProviderUid)
	var i FindAccountByProviderRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.DisplayName,
		&i.PhotoUrl,
		&i.IsActive,
		&i.LastLoginAt,
	)
	return i, err
}

const getAccountByEmail = `-- name: GetAccountByEmail :one
SELECT id, email, email_verified, display_name, photo_url, is_active, last_login_at
FROM authority.accounts
WHERE email = $1 AND deleted_at IS NULL
`

type GetAccountByEmailRow struct {
	ID            uuid.UUID      `json:"id"`
	Email         string         `json:"email"`
	EmailVerified sql.NullBool   `json:"email_verified"`
	DisplayName   sql.NullString `json:"display_name"`
	PhotoUrl      sql.NullString `json:"photo_url"`
	IsActive      sql.NullBool   `json:"is_active"`
	LastLoginAt   sql.NullTime   `json:"last_login_at"`
}

func (q *Queries) GetAccountByEmail(ctx context.Context, email string) (GetAccountByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountByEmail, email)
	var i GetAccountByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.DisplayName,
		&i.PhotoUrl,
		&i.IsActive,
		&i.LastLoginAt,
	)
	return i, err
}

const getAccountByID = `-- name: GetAccountByID :one
SELECT id, email, email_verified, display_name, photo_url, is_active, last_login_at
FROM authority.accounts
WHERE id = $1 AND deleted_at IS NULL
`

type GetAccountByIDRow struct {
	ID            uuid.UUID      `json:"id"`
	Email         string         `json:"email"`
	EmailVerified sql.NullBool   `json:"email_verified"`
	DisplayName   sql.NullString `json:"display_name"`
	PhotoUrl      sql.NullString `json:"photo_url"`
	IsActive      sql.NullBool   `json:"is_active"`
	LastLoginAt   sql.NullTime   `json:"last_login_at"`
}

func (q *Queries) GetAccountByID(ctx context.Context, id uuid.UUID) (GetAccountByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountByID, id)
	var i GetAccountByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.DisplayName,
		&i.PhotoUrl,
		&i.IsActive,
		&i.LastLoginAt,
	)
	return i, err
}

const listIdentitiesByAccount = `-- name: ListIdentitiesByAccount :many
SELECT provider, provider_uid FROM authority.account_identities WHERE account_id = $1 ORDER BY created_at ASC
`

type ListIdentitiesByAccountRow struct {
	Provider    string         `json:"provider"`
	ProviderUid sql.NullString `json:"provider_uid"`
}

func (q *Queries) ListIdentitiesByAccount(ctx context.Context, accountID uuid.UUID) ([]ListIdentitiesByAccountRow, error) {
	rows, err := q.db.QueryContext(ctx, listIdentitiesByAccount, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIdentitiesByAccountRow
	for rows.Next() {
		var i ListIdentitiesByAccountRow
		if err := rows.Scan(&i.Provider, &i.ProviderUid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRolesByAccount = `-- name: ListRolesByAccount :many
SELECT r.name FROM authority.roles r
JOIN authority.account_roles ar ON ar.role_id = r.id
WHERE ar.account_id = $1
`

func (q *Queries) ListRolesByAccount(ctx context.Context, accountID uuid.UUID) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listRolesByAccount, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeRole = `-- name: RevokeRole :exec
DELETE FROM authority.account_roles ar USING authority.roles r
WHERE ar.account_id = $1 AND ar.role_id = r.id AND r.name = $2
`

type RevokeRoleParams struct {
	AccountID uuid.UUID `json:"account_id"`
	Name      string    `json:"name"`
}

func (q *Queries) RevokeRole(ctx context.Context, arg RevokeRoleParams) error {
	_, err := q.db.ExecContext(ctx, revokeRole, arg.AccountID, arg.Name)
	return err
}

const upsertAccount = `-- name: UpsertAccount :exec
INSERT INTO authority.accounts (id, email, email_verified, display_name, photo_url, is_active, last_login_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, now())
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  email_verified = EXCLUDED.email_verified,
  display_name = EXCLUDED.display_name,
  photo_url = EXCLUDED.photo_url,
  is_active = EXCLUDED.is_active,
  last_login_at = EXCLUDED.last_login_at,
  updated_at = now()
`

type UpsertAccountParams struct {
	ID            uuid.UUID      `json:"id"`
	Email         string         `json:"email"`
	EmailVerified sql.NullBool   `json:"email_verified"`
	DisplayName   sql.NullString `json:"display_name"`
	PhotoUrl      sql.NullString `json:"photo_url"`
	IsActive      sql.NullBool   `json:"is_active"`
	LastLoginAt   sql.NullTime   `json:"last_login_at"`
}

func (q *Queries) UpsertAccount(ctx context.Context, arg UpsertAccountParams) error {
	_, err := q.db.ExecContext(ctx, upsertAccount,
		arg.ID,
		arg.Email,
		arg.EmailVerified,
		arg.DisplayName,
		arg.PhotoUrl,
		arg.IsActive,
		arg.LastLoginAt,
	)
	return err
}

const upsertIdentity = `-- name: UpsertIdentity :exec
INSERT INTO authority.account_identities (id, account_id, provider, provider_uid)
VALUES ($1, $2, $3, $4)
ON CONFLICT (account_id, provider) DO UPDATE SET provider_uid = EXCLUDED.provider_uid
`

type UpsertIdentityParams struct {
	ID          uuid.UUID      `json:"id"`
	AccountID   uuid.UUID      `json:"account_id"`
	Provider    string         `json:"provider"`
	ProviderUid sql.NullString `json:"provider_uid"`
}

func (q *Queries) UpsertIdentity(ctx context.Context, arg UpsertIdentityParams) error {
	_, err := q.db.ExecContext(ctx, upsertIdentity,
		arg.ID,
		arg.AccountID,
		arg.Provider,
		arg.ProviderUid,
	)
	return err
}
