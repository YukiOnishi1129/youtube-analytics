// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkVideoExists = `-- name: CheckVideoExists :one
SELECT EXISTS(
    SELECT 1 FROM ingestion.videos 
    WHERE youtube_video_id = $1 AND deleted_at IS NULL
)
`

func (q *Queries) CheckVideoExists(ctx context.Context, youtubeVideoID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkVideoExists, youtubeVideoID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countChannels = `-- name: CountChannels :one
SELECT COUNT(*) FROM ingestion.channels WHERE deleted_at IS NULL
`

func (q *Queries) CountChannels(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countChannels)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVideosByChannel = `-- name: CountVideosByChannel :one
SELECT COUNT(*) FROM ingestion.videos
WHERE channel_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountVideosByChannel(ctx context.Context, channelID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countVideosByChannel, channelID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChannel = `-- name: CreateChannel :exec
INSERT INTO ingestion.channels (
    id, youtube_channel_id, title, thumbnail_url, subscribed, created_at
) VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateChannelParams struct {
	ID               uuid.UUID    `json:"id"`
	YoutubeChannelID string       `json:"youtube_channel_id"`
	Title            string       `json:"title"`
	ThumbnailUrl     string       `json:"thumbnail_url"`
	Subscribed       sql.NullBool `json:"subscribed"`
	CreatedAt        sql.NullTime `json:"created_at"`
}

func (q *Queries) CreateChannel(ctx context.Context, arg CreateChannelParams) error {
	_, err := q.db.ExecContext(ctx, createChannel,
		arg.ID,
		arg.YoutubeChannelID,
		arg.Title,
		arg.ThumbnailUrl,
		arg.Subscribed,
		arg.CreatedAt,
	)
	return err
}

const createKeyword = `-- name: CreateKeyword :exec
INSERT INTO ingestion.keywords (
    id, name, filter_type, pattern, enabled, description, created_at
) VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateKeywordParams struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	FilterType  string         `json:"filter_type"`
	Pattern     string         `json:"pattern"`
	Enabled     sql.NullBool   `json:"enabled"`
	Description sql.NullString `json:"description"`
	CreatedAt   sql.NullTime   `json:"created_at"`
}

func (q *Queries) CreateKeyword(ctx context.Context, arg CreateKeywordParams) error {
	_, err := q.db.ExecContext(ctx, createKeyword,
		arg.ID,
		arg.Name,
		arg.FilterType,
		arg.Pattern,
		arg.Enabled,
		arg.Description,
		arg.CreatedAt,
	)
	return err
}

const createSnapshotTask = `-- name: CreateSnapshotTask :exec
INSERT INTO ingestion.snapshot_tasks (
    video_id, checkpoint_hour, scheduled_at
) VALUES ($1, $2, $3)
`

type CreateSnapshotTaskParams struct {
	VideoID        uuid.UUID `json:"video_id"`
	CheckpointHour int32     `json:"checkpoint_hour"`
	ScheduledAt    time.Time `json:"scheduled_at"`
}

func (q *Queries) CreateSnapshotTask(ctx context.Context, arg CreateSnapshotTaskParams) error {
	_, err := q.db.ExecContext(ctx, createSnapshotTask, arg.VideoID, arg.CheckpointHour, arg.ScheduledAt)
	return err
}

const createVideo = `-- name: CreateVideo :exec
INSERT INTO ingestion.videos (
    id, youtube_video_id, channel_id, youtube_channel_id, title,
    published_at, category_id, thumbnail_url, video_url, created_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type CreateVideoParams struct {
	ID               uuid.UUID    `json:"id"`
	YoutubeVideoID   string       `json:"youtube_video_id"`
	ChannelID        uuid.UUID    `json:"channel_id"`
	YoutubeChannelID string       `json:"youtube_channel_id"`
	Title            string       `json:"title"`
	PublishedAt      time.Time    `json:"published_at"`
	CategoryID       int32        `json:"category_id"`
	ThumbnailUrl     string       `json:"thumbnail_url"`
	VideoUrl         string       `json:"video_url"`
	CreatedAt        sql.NullTime `json:"created_at"`
}

func (q *Queries) CreateVideo(ctx context.Context, arg CreateVideoParams) error {
	_, err := q.db.ExecContext(ctx, createVideo,
		arg.ID,
		arg.YoutubeVideoID,
		arg.ChannelID,
		arg.YoutubeChannelID,
		arg.Title,
		arg.PublishedAt,
		arg.CategoryID,
		arg.ThumbnailUrl,
		arg.VideoUrl,
		arg.CreatedAt,
	)
	return err
}

const createVideoSnapshot = `-- name: CreateVideoSnapshot :exec
INSERT INTO ingestion.video_snapshots (
    id, video_id, checkpoint_hour, measured_at, views_count,
    likes_count, subscription_count, source, created_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateVideoSnapshotParams struct {
	ID                uuid.UUID    `json:"id"`
	VideoID           uuid.UUID    `json:"video_id"`
	CheckpointHour    int32        `json:"checkpoint_hour"`
	MeasuredAt        time.Time    `json:"measured_at"`
	ViewsCount        int64        `json:"views_count"`
	LikesCount        int64        `json:"likes_count"`
	SubscriptionCount int64        `json:"subscription_count"`
	Source            string       `json:"source"`
	CreatedAt         sql.NullTime `json:"created_at"`
}

func (q *Queries) CreateVideoSnapshot(ctx context.Context, arg CreateVideoSnapshotParams) error {
	_, err := q.db.ExecContext(ctx, createVideoSnapshot,
		arg.ID,
		arg.VideoID,
		arg.CheckpointHour,
		arg.MeasuredAt,
		arg.ViewsCount,
		arg.LikesCount,
		arg.SubscriptionCount,
		arg.Source,
		arg.CreatedAt,
	)
	return err
}

const deleteSnapshotTask = `-- name: DeleteSnapshotTask :exec
DELETE FROM ingestion.snapshot_tasks
WHERE video_id = $1 AND checkpoint_hour = $2
`

type DeleteSnapshotTaskParams struct {
	VideoID        uuid.UUID `json:"video_id"`
	CheckpointHour int32     `json:"checkpoint_hour"`
}

func (q *Queries) DeleteSnapshotTask(ctx context.Context, arg DeleteSnapshotTaskParams) error {
	_, err := q.db.ExecContext(ctx, deleteSnapshotTask, arg.VideoID, arg.CheckpointHour)
	return err
}

const getChannelByID = `-- name: GetChannelByID :one
SELECT id, youtube_channel_id, title, thumbnail_url, subscribed, created_at, updated_at
FROM ingestion.channels
WHERE id = $1 AND deleted_at IS NULL
`

type GetChannelByIDRow struct {
	ID               uuid.UUID    `json:"id"`
	YoutubeChannelID string       `json:"youtube_channel_id"`
	Title            string       `json:"title"`
	ThumbnailUrl     string       `json:"thumbnail_url"`
	Subscribed       sql.NullBool `json:"subscribed"`
	CreatedAt        sql.NullTime `json:"created_at"`
	UpdatedAt        sql.NullTime `json:"updated_at"`
}

func (q *Queries) GetChannelByID(ctx context.Context, id uuid.UUID) (GetChannelByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getChannelByID, id)
	var i GetChannelByIDRow
	err := row.Scan(
		&i.ID,
		&i.YoutubeChannelID,
		&i.Title,
		&i.ThumbnailUrl,
		&i.Subscribed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChannelByYouTubeID = `-- name: GetChannelByYouTubeID :one
SELECT id, youtube_channel_id, title, thumbnail_url, subscribed, created_at, updated_at
FROM ingestion.channels
WHERE youtube_channel_id = $1 AND deleted_at IS NULL
`

type GetChannelByYouTubeIDRow struct {
	ID               uuid.UUID    `json:"id"`
	YoutubeChannelID string       `json:"youtube_channel_id"`
	Title            string       `json:"title"`
	ThumbnailUrl     string       `json:"thumbnail_url"`
	Subscribed       sql.NullBool `json:"subscribed"`
	CreatedAt        sql.NullTime `json:"created_at"`
	UpdatedAt        sql.NullTime `json:"updated_at"`
}

func (q *Queries) GetChannelByYouTubeID(ctx context.Context, youtubeChannelID string) (GetChannelByYouTubeIDRow, error) {
	row := q.db.QueryRowContext(ctx, getChannelByYouTubeID, youtubeChannelID)
	var i GetChannelByYouTubeIDRow
	err := row.Scan(
		&i.ID,
		&i.YoutubeChannelID,
		&i.Title,
		&i.ThumbnailUrl,
		&i.Subscribed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getKeywordByID = `-- name: GetKeywordByID :one
SELECT id, name, filter_type, pattern, enabled, description, created_at, updated_at
FROM ingestion.keywords
WHERE id = $1 AND deleted_at IS NULL
`

type GetKeywordByIDRow struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	FilterType  string         `json:"filter_type"`
	Pattern     string         `json:"pattern"`
	Enabled     sql.NullBool   `json:"enabled"`
	Description sql.NullString `json:"description"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
}

func (q *Queries) GetKeywordByID(ctx context.Context, id uuid.UUID) (GetKeywordByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getKeywordByID, id)
	var i GetKeywordByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.FilterType,
		&i.Pattern,
		&i.Enabled,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingSnapshotTasks = `-- name: GetPendingSnapshotTasks :many
SELECT video_id, checkpoint_hour, scheduled_at
FROM ingestion.snapshot_tasks
WHERE scheduled_at <= $1
ORDER BY scheduled_at ASC
LIMIT $2
`

type GetPendingSnapshotTasksParams struct {
	ScheduledAt time.Time `json:"scheduled_at"`
	Limit       int32     `json:"limit"`
}

func (q *Queries) GetPendingSnapshotTasks(ctx context.Context, arg GetPendingSnapshotTasksParams) ([]IngestionSnapshotTask, error) {
	rows, err := q.db.QueryContext(ctx, getPendingSnapshotTasks, arg.ScheduledAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IngestionSnapshotTask
	for rows.Next() {
		var i IngestionSnapshotTask
		if err := rows.Scan(&i.VideoID, &i.CheckpointHour, &i.ScheduledAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVideoByID = `-- name: GetVideoByID :one
SELECT id, youtube_video_id, youtube_channel_id, title, thumbnail_url, published_at, created_at
FROM ingestion.videos
WHERE id = $1 AND deleted_at IS NULL
`

type GetVideoByIDRow struct {
	ID               uuid.UUID    `json:"id"`
	YoutubeVideoID   string       `json:"youtube_video_id"`
	YoutubeChannelID string       `json:"youtube_channel_id"`
	Title            string       `json:"title"`
	ThumbnailUrl     string       `json:"thumbnail_url"`
	PublishedAt      time.Time    `json:"published_at"`
	CreatedAt        sql.NullTime `json:"created_at"`
}

func (q *Queries) GetVideoByID(ctx context.Context, id uuid.UUID) (GetVideoByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getVideoByID, id)
	var i GetVideoByIDRow
	err := row.Scan(
		&i.ID,
		&i.YoutubeVideoID,
		&i.YoutubeChannelID,
		&i.Title,
		&i.ThumbnailUrl,
		&i.PublishedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getVideoByYouTubeID = `-- name: GetVideoByYouTubeID :one
SELECT id, youtube_video_id, youtube_channel_id, title, thumbnail_url, published_at, created_at
FROM ingestion.videos
WHERE youtube_video_id = $1 AND deleted_at IS NULL
`

type GetVideoByYouTubeIDRow struct {
	ID               uuid.UUID    `json:"id"`
	YoutubeVideoID   string       `json:"youtube_video_id"`
	YoutubeChannelID string       `json:"youtube_channel_id"`
	Title            string       `json:"title"`
	ThumbnailUrl     string       `json:"thumbnail_url"`
	PublishedAt      time.Time    `json:"published_at"`
	CreatedAt        sql.NullTime `json:"created_at"`
}

func (q *Queries) GetVideoByYouTubeID(ctx context.Context, youtubeVideoID string) (GetVideoByYouTubeIDRow, error) {
	row := q.db.QueryRowContext(ctx, getVideoByYouTubeID, youtubeVideoID)
	var i GetVideoByYouTubeIDRow
	err := row.Scan(
		&i.ID,
		&i.YoutubeVideoID,
		&i.YoutubeChannelID,
		&i.Title,
		&i.ThumbnailUrl,
		&i.PublishedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getVideoSnapshotByVideoAndCheckpoint = `-- name: GetVideoSnapshotByVideoAndCheckpoint :one
SELECT id, video_id, checkpoint_hour, measured_at, views_count, 
       likes_count, subscription_count, source, created_at
FROM ingestion.video_snapshots
WHERE video_id = $1 AND checkpoint_hour = $2
`

type GetVideoSnapshotByVideoAndCheckpointParams struct {
	VideoID        uuid.UUID `json:"video_id"`
	CheckpointHour int32     `json:"checkpoint_hour"`
}

func (q *Queries) GetVideoSnapshotByVideoAndCheckpoint(ctx context.Context, arg GetVideoSnapshotByVideoAndCheckpointParams) (IngestionVideoSnapshot, error) {
	row := q.db.QueryRowContext(ctx, getVideoSnapshotByVideoAndCheckpoint, arg.VideoID, arg.CheckpointHour)
	var i IngestionVideoSnapshot
	err := row.Scan(
		&i.ID,
		&i.VideoID,
		&i.CheckpointHour,
		&i.MeasuredAt,
		&i.ViewsCount,
		&i.LikesCount,
		&i.SubscriptionCount,
		&i.Source,
		&i.CreatedAt,
	)
	return i, err
}

const listActiveChannels = `-- name: ListActiveChannels :many
SELECT id, youtube_channel_id, title, thumbnail_url, subscribed, created_at, updated_at
FROM ingestion.channels
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

type ListActiveChannelsRow struct {
	ID               uuid.UUID    `json:"id"`
	YoutubeChannelID string       `json:"youtube_channel_id"`
	Title            string       `json:"title"`
	ThumbnailUrl     string       `json:"thumbnail_url"`
	Subscribed       sql.NullBool `json:"subscribed"`
	CreatedAt        sql.NullTime `json:"created_at"`
	UpdatedAt        sql.NullTime `json:"updated_at"`
}

func (q *Queries) ListActiveChannels(ctx context.Context) ([]ListActiveChannelsRow, error) {
	rows, err := q.db.QueryContext(ctx, listActiveChannels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveChannelsRow
	for rows.Next() {
		var i ListActiveChannelsRow
		if err := rows.Scan(
			&i.ID,
			&i.YoutubeChannelID,
			&i.Title,
			&i.ThumbnailUrl,
			&i.Subscribed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveVideos = `-- name: ListActiveVideos :many
SELECT id, youtube_video_id, youtube_channel_id, title, thumbnail_url, published_at, created_at
FROM ingestion.videos
WHERE published_at > $1 AND deleted_at IS NULL
ORDER BY published_at DESC
`

type ListActiveVideosRow struct {
	ID               uuid.UUID    `json:"id"`
	YoutubeVideoID   string       `json:"youtube_video_id"`
	YoutubeChannelID string       `json:"youtube_channel_id"`
	Title            string       `json:"title"`
	ThumbnailUrl     string       `json:"thumbnail_url"`
	PublishedAt      time.Time    `json:"published_at"`
	CreatedAt        sql.NullTime `json:"created_at"`
}

func (q *Queries) ListActiveVideos(ctx context.Context, publishedAt time.Time) ([]ListActiveVideosRow, error) {
	rows, err := q.db.QueryContext(ctx, listActiveVideos, publishedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveVideosRow
	for rows.Next() {
		var i ListActiveVideosRow
		if err := rows.Scan(
			&i.ID,
			&i.YoutubeVideoID,
			&i.YoutubeChannelID,
			&i.Title,
			&i.ThumbnailUrl,
			&i.PublishedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChannels = `-- name: ListChannels :many
SELECT id, youtube_channel_id, title, thumbnail_url, subscribed, created_at, updated_at
FROM ingestion.channels
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListChannelsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListChannelsRow struct {
	ID               uuid.UUID    `json:"id"`
	YoutubeChannelID string       `json:"youtube_channel_id"`
	Title            string       `json:"title"`
	ThumbnailUrl     string       `json:"thumbnail_url"`
	Subscribed       sql.NullBool `json:"subscribed"`
	CreatedAt        sql.NullTime `json:"created_at"`
	UpdatedAt        sql.NullTime `json:"updated_at"`
}

func (q *Queries) ListChannels(ctx context.Context, arg ListChannelsParams) ([]ListChannelsRow, error) {
	rows, err := q.db.QueryContext(ctx, listChannels, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChannelsRow
	for rows.Next() {
		var i ListChannelsRow
		if err := rows.Scan(
			&i.ID,
			&i.YoutubeChannelID,
			&i.Title,
			&i.ThumbnailUrl,
			&i.Subscribed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnabledKeywords = `-- name: ListEnabledKeywords :many
SELECT id, name, filter_type, pattern, enabled, description, created_at, updated_at
FROM ingestion.keywords
WHERE enabled = true AND deleted_at IS NULL
ORDER BY name ASC
`

type ListEnabledKeywordsRow struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	FilterType  string         `json:"filter_type"`
	Pattern     string         `json:"pattern"`
	Enabled     sql.NullBool   `json:"enabled"`
	Description sql.NullString `json:"description"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
}

func (q *Queries) ListEnabledKeywords(ctx context.Context) ([]ListEnabledKeywordsRow, error) {
	rows, err := q.db.QueryContext(ctx, listEnabledKeywords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEnabledKeywordsRow
	for rows.Next() {
		var i ListEnabledKeywordsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.FilterType,
			&i.Pattern,
			&i.Enabled,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscribedChannels = `-- name: ListSubscribedChannels :many
SELECT id, youtube_channel_id, title, thumbnail_url, subscribed, created_at, updated_at
FROM ingestion.channels
WHERE subscribed = true AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ListSubscribedChannelsRow struct {
	ID               uuid.UUID    `json:"id"`
	YoutubeChannelID string       `json:"youtube_channel_id"`
	Title            string       `json:"title"`
	ThumbnailUrl     string       `json:"thumbnail_url"`
	Subscribed       sql.NullBool `json:"subscribed"`
	CreatedAt        sql.NullTime `json:"created_at"`
	UpdatedAt        sql.NullTime `json:"updated_at"`
}

func (q *Queries) ListSubscribedChannels(ctx context.Context) ([]ListSubscribedChannelsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSubscribedChannels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSubscribedChannelsRow
	for rows.Next() {
		var i ListSubscribedChannelsRow
		if err := rows.Scan(
			&i.ID,
			&i.YoutubeChannelID,
			&i.Title,
			&i.ThumbnailUrl,
			&i.Subscribed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideoSnapshots = `-- name: ListVideoSnapshots :many
SELECT id, video_id, checkpoint_hour, measured_at, views_count, 
       likes_count, subscription_count, source, created_at
FROM ingestion.video_snapshots
WHERE video_id = $1
ORDER BY checkpoint_hour ASC
`

func (q *Queries) ListVideoSnapshots(ctx context.Context, videoID uuid.UUID) ([]IngestionVideoSnapshot, error) {
	rows, err := q.db.QueryContext(ctx, listVideoSnapshots, videoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IngestionVideoSnapshot
	for rows.Next() {
		var i IngestionVideoSnapshot
		if err := rows.Scan(
			&i.ID,
			&i.VideoID,
			&i.CheckpointHour,
			&i.MeasuredAt,
			&i.ViewsCount,
			&i.LikesCount,
			&i.SubscriptionCount,
			&i.Source,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideosByChannel = `-- name: ListVideosByChannel :many
SELECT id, youtube_video_id, youtube_channel_id, title, thumbnail_url, published_at, created_at
FROM ingestion.videos
WHERE channel_id = $1 AND deleted_at IS NULL
ORDER BY published_at DESC
LIMIT $2 OFFSET $3
`

type ListVideosByChannelParams struct {
	ChannelID uuid.UUID `json:"channel_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type ListVideosByChannelRow struct {
	ID               uuid.UUID    `json:"id"`
	YoutubeVideoID   string       `json:"youtube_video_id"`
	YoutubeChannelID string       `json:"youtube_channel_id"`
	Title            string       `json:"title"`
	ThumbnailUrl     string       `json:"thumbnail_url"`
	PublishedAt      time.Time    `json:"published_at"`
	CreatedAt        sql.NullTime `json:"created_at"`
}

func (q *Queries) ListVideosByChannel(ctx context.Context, arg ListVideosByChannelParams) ([]ListVideosByChannelRow, error) {
	rows, err := q.db.QueryContext(ctx, listVideosByChannel, arg.ChannelID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVideosByChannelRow
	for rows.Next() {
		var i ListVideosByChannelRow
		if err := rows.Scan(
			&i.ID,
			&i.YoutubeVideoID,
			&i.YoutubeChannelID,
			&i.Title,
			&i.ThumbnailUrl,
			&i.PublishedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChannel = `-- name: UpdateChannel :exec
UPDATE ingestion.channels
SET title = $2, thumbnail_url = $3, subscribed = $4, updated_at = $5, deleted_at = $6
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateChannelParams struct {
	ID           uuid.UUID    `json:"id"`
	Title        string       `json:"title"`
	ThumbnailUrl string       `json:"thumbnail_url"`
	Subscribed   sql.NullBool `json:"subscribed"`
	UpdatedAt    sql.NullTime `json:"updated_at"`
	DeletedAt    sql.NullTime `json:"deleted_at"`
}

func (q *Queries) UpdateChannel(ctx context.Context, arg UpdateChannelParams) error {
	_, err := q.db.ExecContext(ctx, updateChannel,
		arg.ID,
		arg.Title,
		arg.ThumbnailUrl,
		arg.Subscribed,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	return err
}
